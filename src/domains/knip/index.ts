import type { CheckResult, CommandOptions, Issue } from "../../types/index";
import type { WorkspaceConfig } from "./detectors";
import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import mergeWith from "lodash/mergeWith";
import { ConfigManager } from "../../config/loader";
import * as logger from "../../utils/logger";
import { getWorkspaceInfo } from "../../utils/workspace";
import { detectFramework } from "./detectors";

interface KnipGenerateOptions extends CommandOptions {
    force?: boolean;
}

interface KnipGenerateResult {
    success: boolean;
    generated: number;
    skipped: number;
    scriptsAdded: number;
}

function formatPluginConfig(
    value: boolean | { config?: string[]; entry?: string[] },
): string {
    if (value === true || value === false) return String(value);
    const parts: string[] = [];
    if (value.config) parts.push(`config: ${JSON.stringify(value.config)}`);
    if (value.entry) parts.push(`entry: ${JSON.stringify(value.entry)}`);
    return `{ ${parts.join(", ")} }`;
}

function generateKnipConfigContent(
    config: WorkspaceConfig,
    schemaOverrides?: Record<string, unknown>,
): string {
    const entryArray = JSON.stringify(config.entry || ["src/index.ts"]);
    const projectArray = JSON.stringify(config.project || ["src/**/*.ts"]);

    const lines: string[] = [];

    if (config.ignoreBinaries?.length) {
        lines.push(`    ignoreBinaries: ${JSON.stringify(config.ignoreBinaries)},`);
    }
    if (config.ignoreDependencies?.length) {
        lines.push(`    ignoreDependencies: ${JSON.stringify(config.ignoreDependencies)},`);
    }
    if (config.vite) {
        lines.push(`    vite: ${formatPluginConfig(config.vite)},`);
    }
    if (config.tailwind) {
        lines.push(`    tailwind: ${formatPluginConfig(config.tailwind)},`);
    }
    if (config.postcss) {
        lines.push(`    postcss: ${formatPluginConfig(config.postcss)},`);
    }

    const extraLines = lines.length > 0 ? `\n${lines.join("\n")}` : "";

    // Serialize schema overrides as second arg to defineKnipConfig
    const schemaArg = schemaOverrides && Object.keys(schemaOverrides).length > 0
        ? `, ${JSON.stringify(schemaOverrides, null, 4).split("\n").map((line, i) => i === 0 ? line : `${line}`).join("\n")}`
        : "";

    if (config.useVueCompiler) {
        return `// Generated by @adddog/monorepo-consistency
// Do not edit manually - regenerate with: mono knip generate
import { defineKnipConfig } from "@adddog/monorepo-consistency";
import { parse } from "vue/compiler-sfc";

export default defineKnipConfig({
    entry: ${entryArray},
    project: ${projectArray},${extraLines}
    compilers: {
        vue: (text: string, filename: string) => {
            const { descriptor } = parse(text, { filename, sourceMap: false });
            return [
                descriptor.script?.content ?? "",
                descriptor.scriptSetup?.content ?? "",
            ].join("\\n");
        },
    },
}${schemaArg});
`;
    }

    return `// Generated by @adddog/monorepo-consistency
// Do not edit manually - regenerate with: mono knip generate
import { defineKnipConfig } from "@adddog/monorepo-consistency";

export default defineKnipConfig({
    entry: ${entryArray},
    project: ${projectArray},${extraLines}
}${schemaArg});
`;
}

async function addKnipScriptToPackageJson(pkgPath: string): Promise<boolean> {
    const pkgJsonPath = join(pkgPath, "package.json");
    const content = await readFile(pkgJsonPath, "utf-8");
    const pkg = JSON.parse(content);

    if (pkg.scripts?.knip === "knip") {
        return false;
    }

    pkg.scripts = pkg.scripts || {};
    pkg.scripts.knip = "knip";

    await writeFile(pkgJsonPath, `${JSON.stringify(pkg, null, 2)}\n`);
    return true;
}

/**
 * Generate knip.config.ts files for all workspace packages
 */
const generate = async (options: KnipGenerateOptions): Promise<KnipGenerateResult> => {
    const spinner = logger.spinner("Generating knip configurations...");
    spinner.start();

    try {
        const workspace = await getWorkspaceInfo(options.cwd);
        const configManager = ConfigManager.getInstance();
        const config = configManager.getConfig();
        const knipConfig = config?.knip;
        const addScript = knipConfig?.addScriptToPackageJson ?? true;
        const frameworkDetection = knipConfig?.frameworkDetection ?? true;

        let generated = 0;
        let skipped = 0;
        let scriptsAdded = 0;

        // Schema-level knip overrides
        const schemaDefaults = knipConfig?.defaults;
        const schemaPackages = knipConfig?.packages;

        for (const pkg of workspace.packages) {
            const knipConfigPath = join(pkg.path, "knip.config.ts");

            // Skip if exists and not forced
            if (!options.force && existsSync(knipConfigPath)) {
                skipped++;
                continue;
            }

            const framework = frameworkDetection
                ? await detectFramework(pkg.path)
                : { name: "default", config: { entry: ["src/index.ts"], project: ["src/**/*.ts"] } };

            // Merge schema-level defaults + per-package overrides
            let schemaOverrides: Record<string, unknown> | undefined;
            const pkgOverrides = schemaPackages?.[pkg.name];
            if (schemaDefaults || pkgOverrides) {
                schemaOverrides = mergeWith(
                    {},
                    schemaDefaults ?? {},
                    pkgOverrides ?? {},
                    (objValue: unknown, srcValue: unknown) => {
                        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
                            return [...objValue, ...srcValue];
                        }
                        return undefined;
                    },
                );
            }

            const content = generateKnipConfigContent(framework.config, schemaOverrides);

            if (options.dryRun) {
                logger.info(`[DRY RUN] Would generate ${knipConfigPath} (${framework.name})`);
            } else {
                await writeFile(knipConfigPath, content);
            }

            generated++;

            if (addScript && !options.dryRun) {
                const added = await addKnipScriptToPackageJson(pkg.path);
                if (added) scriptsAdded++;
            }

            logger.debug(`  ${pkg.name}: ${framework.name}`);
        }

        spinner.succeed(`Generated ${generated} knip config(s), skipped ${skipped}, added ${scriptsAdded} script(s)`);

        return { success: true, generated, skipped, scriptsAdded };
    } catch (error) {
        spinner.fail("Knip configuration generation failed");
        throw error;
    }
};

/**
 * Check that all workspace packages have knip.config.ts
 */
const check = async (options: CommandOptions): Promise<CheckResult> => {
    const spinner = logger.spinner("Checking knip configurations...");
    spinner.start();

    const issues: Issue[] = [];

    try {
        const workspace = await getWorkspaceInfo(options.cwd);

        for (const pkg of workspace.packages) {
            const knipConfigPath = join(pkg.path, "knip.config.ts");

            if (!existsSync(knipConfigPath)) {
                issues.push({
                    severity: "medium",
                    type: "missing-knip-config",
                    package: pkg.name,
                    file: knipConfigPath,
                    message: `Missing knip.config.ts`,
                    fix: "Run: mono knip generate",
                });
            }

            if (!pkg.scripts?.knip) {
                issues.push({
                    severity: "low",
                    type: "missing-knip-script",
                    package: pkg.name,
                    message: `Missing "knip" script in package.json`,
                    fix: "Run: mono knip generate",
                });
            }
        }

        spinner.succeed(`Checked ${workspace.packages.length} packages`);

        return {
            success: issues.length === 0,
            issues,
            stats: {
                total: issues.length,
                critical: issues.filter(i => i.severity === "critical").length,
                high: issues.filter(i => i.severity === "high").length,
                medium: issues.filter(i => i.severity === "medium").length,
                low: issues.filter(i => i.severity === "low").length,
            },
        };
    } catch (error) {
        spinner.fail("Knip configuration check failed");
        throw error;
    }
};

export const knipHandler = { generate, check };
