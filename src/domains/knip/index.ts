import type { CheckResult, CommandOptions, Issue } from "../../types/index.js";
import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { ConfigManager } from "../../config/loader.js";
import * as logger from "../../utils/logger.js";
import { getWorkspaceInfo } from "../../utils/workspace.js";
import { detectFramework } from "./detectors.js";

interface KnipGenerateOptions extends CommandOptions {
    force?: boolean;
}

interface KnipGenerateResult {
    success: boolean;
    generated: number;
    skipped: number;
    scriptsAdded: number;
}

function generateKnipConfigContent(
    config: { entry?: string[]; project?: string[]; ignoreBinaries?: string[] },
): string {
    const entryArray = JSON.stringify(config.entry || ["src/index.ts"]);
    const projectArray = JSON.stringify(config.project || ["src/**/*.ts"]);
    const ignoreBinariesLine = config.ignoreBinaries?.length
        ? `\n    ignoreBinaries: ${JSON.stringify(config.ignoreBinaries)},`
        : "";

    return `// Generated by @adddog/monorepo-consistency
// Do not edit manually - regenerate with: mono knip generate
import { defineKnipConfig } from "@adddog/monorepo-consistency";

export default defineKnipConfig({
    entry: ${entryArray},
    project: ${projectArray},${ignoreBinariesLine}
});
`;
}

async function addKnipScriptToPackageJson(pkgPath: string): Promise<boolean> {
    const pkgJsonPath = join(pkgPath, "package.json");
    const content = await readFile(pkgJsonPath, "utf-8");
    const pkg = JSON.parse(content);

    if (pkg.scripts?.knip === "knip") {
        return false;
    }

    pkg.scripts = pkg.scripts || {};
    pkg.scripts.knip = "knip";

    await writeFile(pkgJsonPath, `${JSON.stringify(pkg, null, 2)}\n`);
    return true;
}

/**
 * Generate knip.config.ts files for all workspace packages
 */
const generate = async (options: KnipGenerateOptions): Promise<KnipGenerateResult> => {
    const spinner = logger.spinner("Generating knip configurations...");
    spinner.start();

    try {
        const workspace = await getWorkspaceInfo(options.cwd);
        const configManager = ConfigManager.getInstance();
        const config = configManager.getConfig();
        const knipConfig = config?.knip;
        const addScript = knipConfig?.addScriptToPackageJson ?? true;
        const frameworkDetection = knipConfig?.frameworkDetection ?? true;

        let generated = 0;
        let skipped = 0;
        let scriptsAdded = 0;

        for (const pkg of workspace.packages) {
            const knipConfigPath = join(pkg.path, "knip.config.ts");

            // Skip if exists and not forced
            if (!options.force && existsSync(knipConfigPath)) {
                skipped++;
                continue;
            }

            const framework = frameworkDetection
                ? await detectFramework(pkg.path)
                : { name: "default", config: { entry: ["src/index.ts"], project: ["src/**/*.ts"] } };

            const content = generateKnipConfigContent(framework.config);

            if (options.dryRun) {
                logger.info(`[DRY RUN] Would generate ${knipConfigPath} (${framework.name})`);
            } else {
                await writeFile(knipConfigPath, content);
            }

            generated++;

            if (addScript && !options.dryRun) {
                const added = await addKnipScriptToPackageJson(pkg.path);
                if (added) scriptsAdded++;
            }

            logger.debug(`  ${pkg.name}: ${framework.name}`);
        }

        spinner.succeed(`Generated ${generated} knip config(s), skipped ${skipped}, added ${scriptsAdded} script(s)`);

        return { success: true, generated, skipped, scriptsAdded };
    } catch (error) {
        spinner.fail("Knip configuration generation failed");
        throw error;
    }
};

/**
 * Check that all workspace packages have knip.config.ts
 */
const check = async (options: CommandOptions): Promise<CheckResult> => {
    const spinner = logger.spinner("Checking knip configurations...");
    spinner.start();

    const issues: Issue[] = [];

    try {
        const workspace = await getWorkspaceInfo(options.cwd);

        for (const pkg of workspace.packages) {
            const knipConfigPath = join(pkg.path, "knip.config.ts");

            if (!existsSync(knipConfigPath)) {
                issues.push({
                    severity: "medium",
                    type: "missing-knip-config",
                    package: pkg.name,
                    file: knipConfigPath,
                    message: `Missing knip.config.ts`,
                    fix: "Run: mono knip generate",
                });
            }

            if (!pkg.scripts?.knip) {
                issues.push({
                    severity: "low",
                    type: "missing-knip-script",
                    package: pkg.name,
                    message: `Missing "knip" script in package.json`,
                    fix: "Run: mono knip generate",
                });
            }
        }

        spinner.succeed(`Checked ${workspace.packages.length} packages`);

        return {
            success: issues.length === 0,
            issues,
            stats: {
                total: issues.length,
                critical: issues.filter(i => i.severity === "critical").length,
                high: issues.filter(i => i.severity === "high").length,
                medium: issues.filter(i => i.severity === "medium").length,
                low: issues.filter(i => i.severity === "low").length,
            },
        };
    } catch (error) {
        spinner.fail("Knip configuration check failed");
        throw error;
    }
};

export const knipHandler = { generate, check };
